--EMPLOYEES 테이블에서 전체 조회
SELECT
	*
FROM
	EMPLOYEES e ;
	
--EMPLOYEES 에서 퍼스트네임 라스트네임, 잡아이디
SELECT
	FIRST_NAME , LAST_NAME , JOB_ID 
FROM
	EMPLOYEES e ;
	
-- 사원번호가 176 인 사람의 last name과 DEaprtment 아이디 조회
SELECT
	LAST_NAME ,
	DEPARTMENT_ID ,
	EMPLOYEE_ID 
FROM
	EMPLOYEES e 
WHERE EMPLOYEE_ID  = 176
-- 연봉이 12000dltkd 되는 직원들의 LASTNAME  및 SALARY 조회

SELECT
	LAST_NAME ,
	SALARY  
FROM
	EMPLOYEES e 
WHERE SALARY >= 12000;
-- 연봉이 5000 에서 12000의 범위 외 사람들의 LASTNAME  과 SALARTY조회
SELECT
	LAST_NAME ,
	SALARY  
FROM
	EMPLOYEES e 
WHERE SALARY < 5000 or SALARY  > 12000;

--부서번호가 20 or 50 에서 근무하는 사원들의 라스트네임 , 디파트먼트 아이디
SELECT
	LAST_NAME ,
	DEPARTMENT_ID 
FROM
	EMPLOYEES e 
WHERE DEPARTMENT_ID  IN (20,50);
--부서번호가 20 or 50 에서 근무하는 사원들의 라스트네임 , 디파트먼트 아이디
SELECT
	LAST_NAME ,
	DEPARTMENT_ID 
FROM
	EMPLOYEES e 
WHERE DEPARTMENT_ID  IN (20,50) ORDER BY LAST_NAME ASC , DEPARTMENT_ID ASC ;
--커미션을 버는 모든 사원들의 라스트네임 셀러리 commision_PCT 조회
SELECT
	LAST_NAME ,
	SALARY ,
	COMMISSION_PCT 
FROM
	EMPLOYEES e 
WHERE COMMISSION_PCT  NOT IN  (0) ORDER BY LAST_NAME DESC , SALARY  DESC, COMMISSION_PCT DESC;
-- salary가 2500,3500,7000 이 아니며 job 이 SA_REP 나 ST_CLERK 사원조회 
SELECT
	*
FROM
	EMPLOYEES e 
WHERE SALARY NOT IN  (2500, 3500, 7000) AND JOB_ID  IN ('SA_REP', 'ST_CLERK');

-- 2017-01-01 ~ 2017-11-31 사이에 고용된 사원들의  라스트네임 , employ id , HIRE date
SELECT
	LAST_NAME ,
	EMPLOYEE_ID ,
	HIRE_DATE 
FROM
	EMPLOYEES e 
WHERE HIRE_DATE BETWEEN  '2017-01-01' AND  '2017-12-31' ORDER  BY HIRE_DATE DESC ;

-- 부서번호가 20/50 에서 근무하고 , 연봉이 5000~12000 사이인 사원들의 LAST_NAME, SALARY
-- 셀러리 오름차순
SELECT
	LAST_NAME ,
	SALARY ,
	DEPARTMENT_ID 
FROM
	EMPLOYEES e 
WHERE DEPARTMENT_ID  IN (20,50) and SALARY  BETWEEN  5000 AND  12000 ORDER  BY SALARY  ASC  ;


SELECT
	LAST_NAME ,
	SALARY ,
	DEPARTMENT_ID 
FROM
	EMPLOYEES e 
WHERE  SALARY NOT  BETWEEN  5000 AND  12000 ORDER  BY SALARY  ASC  ;

--LAST_NAME 에 u가 포함되는 사람들의 사번, last_name
SELECT
	LAST_NAME ,
	EMPLOYEE_ID  
FROM
	EMPLOYEES e 
WHERE  LAST_NAME  LIKE '%u%' ;
--LAST_NAME 에 4번째 문자가가 A인 사람들의 사번, last_name
SELECT
	LAST_NAME ,
	EMPLOYEE_ID  
FROM
	EMPLOYEES e 
WHERE  LAST_NAME  LIKE '___a%' ;
--LAST_NAME 에 a 혹은 e인 사람들의 사번, last_name 오름 차순
SELECT
	LAST_NAME ,
	EMPLOYEE_ID  
FROM
	EMPLOYEES e 
WHERE  LAST_NAME  LIKE '%a%' OR LAST_NAME  LIKE '%e%' ORDER BY LAST_NAME ASC ;
--LAST_NAME 에 a 와 e인 사람들의 사번, last_name 오름 차순
SELECT
	LAST_NAME ,
	EMPLOYEE_ID  
FROM
	EMPLOYEES e 
WHERE  LAST_NAME  LIKE '%a%' and LAST_NAME  LIKE '%e%' ORDER BY LAST_NAME ASC  ;

--MNG 가 없는 사람들의 last, job 조회
SELECT
	LAST_NAME ,
	JOB_ID 
FROM
	EMPLOYEES e 
WHERE  MANAGER_ID  IS NULL  ;
--st_CLEARK 인 jobe 아이디인 가진 사원이 없는 부서 조회
SELECT DISTINCT -- 중복 데이터 제거 
	DEPARTMENT_ID  
FROM
	EMPLOYEES e 
WHERE  JOB_ID  NOT LIKE 'ST_CLERK' AND DEPARTMENT_ID  IS NOT NULL  ;
-- commit가 null 이 아닌 사원들 중에 COMMIT = SALARy * COMMISSION_PCT 를 구하여 EMPLOY, FIRSTn JOB id
SELECT
	EMPLOYEE_ID ,
	JOB_ID,
	SALARY  * COMMISSION_PCT AS "COMMISSION",
	FIRST_NAME 
FROM
	EMPLOYEES e 
WHERE  COMMISSION_PCT  is NOT NULL  ;

SELECT
	EMPLOYEE_ID ,
	JOB_ID,
	SALARY  * COMMISSION_PCT AS "COMMISSION",
	FIRST_NAME ,
	SALARY ,
	COMMISSION_PCT 
FROM
	EMPLOYEES e ;

-- first_name 이 'CURTIS'인 사원의 FIRST_NAME , LSAT_NAME ,EMAIL, PHONE_NUM, JOB_ID를 죄회한다 단 JOB_ID느 소문자로
SELECT
	FIRST_NAME , LAST_NAME , EMAIL , PHONE_NUMBER , LOWER( JOB_ID) 
FROM
	EMPLOYEES  e 
WHERE FIRST_NAME LIKE 'Curtis';
-- 부서번화 60 70 80 90 인 사원들의 EMPLIOYEE, FIRST ,HIRE, JOB조회 단 JOB 가 IT_PROG 인 사원의 경우 프로그래머로 변경
SELECT
	EMPLOYEE_ID ,FIRST_NAME , HIRE_DATE  , REPLACE (JOB_ID ,'IT_PROG', 'PROGRAMMER' ) AS JOB_ID 
FROM
	EMPLOYEES  e 
WHERE DEPARTMENT_ID  IN (60,70,80,90) ;
-- JOB이 AD_PRES , PU_CLERK 인 사원들의 EMPLOYEE, FIRST, JOB 조회 단 사원명은 FIRST와 LAST를 연결
SELECT
	EMPLOYEE_ID ,FIRST_NAME || ' '|| LAST_NAME AS NAME , JOB_ID  
FROM
	EMPLOYEES  e 
WHERE JOB_ID  IN ('AD_PRES','PU_CLERK') ;

-- 부서 80의 각 사원에 대해 적용 가능한 세율을 표시하시오.

SELECT  
	 LAST_NAME ,
	 SALARY ,
	 CASE 
		WHEN SALARY <=1999 THEN '0.0'
		WHEN SALARY BETWEEN 2000 AND 3999 THEN '0.09'
		WHEN SALARY BETWEEN 4000 AND 5999 THEN '0.2'
		WHEN SALARY BETWEEN 6000 AND 7999 THEN '0.3'
		WHEN SALARY BETWEEN 8000 AND 9999 THEN '0.4'
		WHEN SALARY BETWEEN 10000 AND 11999 THEN '0.42'
		WHEN SALARY BETWEEN 12000 AND 13999 THEN '0.44'
		ELSE '0.45'
	END AS TAX_RATE
FROM
	EMPLOYEES e 
WHERE  DEPARTMENT_ID  = 80;

SELECT  
	 LAST_NAME ,
	 SALARY ,
	 CASE trunc(SALARY/2000,0)
		WHEN 0 THEN '0.0'
		WHEN 1 THEN '0.09'
		WHEN 2 THEN '0.2'
		WHEN 3 THEN '0.3'
		WHEN 4 THEN '0.4'
		WHEN 5 THEN '0.42'
		WHEN 6 THEN '0.44'
		ELSE '0.45'
	END AS TAX_RATE
FROM
	EMPLOYEES e 
WHERE  DEPARTMENT_ID  = 80;

--최대 연봉 - 최소 연봉 차이
SELECT  
		MAX(SALARY)AS MAX, MIN(SALARY) AS MIN, MAX(SALARY) - MIN(SALARY) AS DEV
FROM
	EMPLOYEES e ;

-- 메니저로 근무하는 사원들의 총 수 조회 (중복 제거)
SELECT  
	 COUNT(DISTINCT MANAGER_ID)
FROM
	EMPLOYEES e ;

--부서별 직원수 구하기 (부서번호의 ㅗ오름차순)
SELECT DEPARTMENT_ID , COUNT (DEPARTMENT_ID)  
FROM EMPLOYEES e 
GROUP BY DEPARTMENT_ID  
ORDER BY DEPARTMENT_ID  ;
--부서별 평균 급여(부서번호의 ㅗ오름차순)
SELECT DEPARTMENT_ID  , ROUND(AVG( SALARY), 0)  
FROM EMPLOYEES e 
GROUP BY DEPARTMENT_ID  
ORDER BY DEPARTMENT_ID  ;
--동일한 직무를 가진 사원들의 총 수 조회
SELECT JOB_ID  , COUNT(JOB_ID)  
FROM EMPLOYEES e 
GROUP BY JOB_ID  
ORDER BY JOB_ID  ;

--메니저가 관리하는 사원들 중에 최소급여 조회
SELECT MANAGER_ID  , MIN (SALARY)  
FROM EMPLOYEES e 
GROUP BY MANAGER_ID  
ORDER BY MANAGER_ID  ;
--메니저가 관리하는 사원들 중에 최소 급여가 6000 미만인 최소급여 제외
SELECT MANAGER_ID  , MIN (SALARY)  
FROM EMPLOYEES e 
GROUP BY MANAGER_ID HAVING  MIN (SALARY) >=6000
ORDER BY MANAGER_ID  ;
--메니저가 없는 사원 제외
SELECT MANAGER_ID  , MIN (SALARY)  
FROM EMPLOYEES e  
WHERE MANAGER_ID IS NOT NULL    
GROUP BY MANAGER_ID HAVING MIN (SALARY) >=6000
ORDER BY MANAGER_ID  ;


-- 자신의 담당 매니저의 고용일보다 빠른 입사자 찾기
SELECT
	e.EMPLOYEE_ID AS 사원번호 ,
	e.hire_date AS 내입사일,
	e.manager_id AS 매니저아이디,
	e2.HIRE_DATE AS 매니저입사일
FROM
	EMPLOYEES e
JOIN EMPLOYEES e2 ON
	e.MANAGER_ID = e2.EMPLOYEE_ID AND e.hire_date < e2.HIRE_DATE 
GROUP BY
	e.EMPLOYEE_ID ,
	e.hire_date ,
	e.manager_id ,
	e2.HIRE_DATE
ORDER BY
	e.MANAGER_ID;
-- 도시 이름이 t로 시작하는 지역에 사는 사원들의 사번 ,last_name ,부서번호조회
SELECT
	e.EMPLOYEE_ID ,
	e.LAST_Name ,
	e.DEPARTMENT_ID
FROM
	EMPLOYEES e
LEFT JOIN DEPARTMENTS d ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID
LEFT JOIN LOCATIONS l ON
	l.LOCATION_ID = d.LOCATION_ID
WHERE
	l.CITY LIKE 'T%'
GROUP BY
	e.EMPLOYEE_ID ,
	e.LAST_Name ,
	e.DEPARTMENT_ID
ORDER BY
	e.EMPLOYEE_ID ,
	e.LAST_Name ,
	e.DEPARTMENT_ID ;

SELECT *
FROM LOCATIONS l ;
--  위치 아이디가 1700 사원들의 last_name , 부서번호, 연봉 조회
SELECT
	e.DEPARTMENT_ID ,
	e.LAST_Name ,
	e.SALARY
FROM
	EMPLOYEES e
LEFT JOIN DEPARTMENTS d ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID
LEFT JOIN LOCATIONS l ON
	l.LOCATION_ID = d.LOCATION_ID
WHERE
	l.LOCATION_ID LIKE '1700'
GROUP BY
	e.SALARY ,
	e.LAST_Name ,
	e.DEPARTMENT_ID
ORDER BY
	e.SALARY ,
	e.LAST_Name ,
	e.DEPARTMENT_ID ;

SELECT *
FROM LOCATIONS l ;
--부서명, 위치id ,각 부서별 사원수,  각 부서별 평균 연봉 조회
--평균 연봉은 소수점 2번째 자리 까지 조회
SELECT
	d.DEPARTMENT_NAME ,
	l.LOCATION_ID ,
	count(e.DEPARTMENT_ID) ,
	trunc(avg(e.SALARY), 2)
FROM
	EMPLOYEES e
LEFT JOIN DEPARTMENTS d ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID
LEFT JOIN LOCATIONS l ON
	l.LOCATION_ID = d.LOCATION_ID
GROUP BY
	d.DEPARTMENT_NAME ,
	l.LOCATION_ID
ORDER BY
	d.DEPARTMENT_NAME ,
	l.LOCATION_ID ;

--excutive 부서에 근무하는 사원들의 부서번호, last_name , job_id 조회
SELECT
	d.DEPARTMENT_ID ,
	e.LAST_NAME ,
	e.JOB_ID
FROM
	EMPLOYEES e
LEFT JOIN DEPARTMENTS d ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID
LEFT JOIN LOCATIONS l ON
	l.LOCATION_ID = d.LOCATION_ID
WHERE
	d.DEPARTMENT_NAME LIKE 'Executive'   
GROUP BY
	d.DEPARTMENT_ID ,
	e.LAST_NAME ,
	e.JOB_ID
ORDER BY
	d.DEPARTMENT_ID ,
	e.LAST_NAME ,
	e.JOB_ID 

-- 각 사원별 소속 부서에서 자신보다 늦게 고용되었으나 많은 연봉을 받는 사원 이 존재 하는 사원의 이름 조회
--이름은 first + last 결합
--부서번호 ,결합이름 ,salary, hire_date 출력
SELECT
	DISTINCT e.DEPARTMENT_ID AS 부서번호  ,e.first_name || ' ' || e.last_name AS 내이름 , e.salary AS 나의급여 , e.hire_date AS 나의입사일
FROM
	EMPLOYEES e JOIN  EMPLOYEES e2 ON e.department_id = e2.DEPARTMENT_ID AND e.salary < e2.SALARY AND e.hire_date < e2.HIRE_DATE 
;

SELECT
	DISTINCT e2.DEPARTMENT_ID AS 부서번호  ,e2.first_name || ' ' || e2.last_name AS 내이름 , e2.salary AS 나의급여 , e2.hire_date AS 나의입사일
FROM
	EMPLOYEES e JOIN  EMPLOYEES e2 ON e.departm  ent_id = e2.DEPARTMENT_ID AND e.salary < e2.SALARY AND e.hire_date < e2.HIRE_DATE 
;

--LAST_NAME 에 U 가 포함되는 사원들과 동일 부서에 근무하는 사원들의 사번 및 LAST_NAME 조회

SELECT 
	E.EMPLOYEE_ID ,
	E.LAST_NAME
FROM
	EMPLOYEES e
WHERE E.DEPARTMENT_ID  IN (SELECT DEPARTMENT_ID 
FROM	EMPLOYEES e 
WHERE e.FIRST_NAME LIKE '%u%');


SELECT 
	JOB_ID  ,
	EMPLOYEE_ID 
FROM
	EMPLOYEES e
WHERE E.DEPARTMENT_ID  IN (SELECT DEPARTMENT_ID 
FROM	EMPLOYEES e 
WHERE e.FIRST_NAME LIKE '%u%');


-- e기존의 작업을 여전히 가지고 있는 사원들의 사번 및 job_id 조회

SELECT 
	e.EMPLOYEE_ID ,
	e.JOb_id
FROM EMPLOYEES e  
WHERE (e.EMPLOYEE_ID, JOB_ID ) IN (SELECT jh.EMPLOYEE_ID, jh.JOB_ID 
FROM JOB_HISTORY jh);

-- select 서브쿼리
-- 각 직무별 연봉총합  및 각 부서별 연봉 총합 조회

SELECT DISTINCT  
	e.JOB_ID,(SELECT sum(SALARY) FROM EMPLOYEES e2 WHERE E2.DEPARTMENT_ID =  10 AND e2.JOB_ID = e.JOB_ID) AS 직무별1,
	(SELECT sum(SALARY) FROM EMPLOYEES e2 WHERE E2.DEPARTMENT_ID =  20 AND e2.JOB_ID = e.JOB_ID) AS 직무별2,
	(SELECT sum(SALARY) FROM EMPLOYEES e2 WHERE E2.DEPARTMENT_ID =  30 AND e2.JOB_ID = e.JOB_ID) AS 직무별3,
	(SELECT sum(SALARY) FROM EMPLOYEES e2 WHERE E2.DEPARTMENT_ID =  40 AND e2.JOB_ID = e.JOB_ID) AS 직무별4,
	(SELECT sum(SALARY) FROM EMPLOYEES e2 WHERE E2.DEPARTMENT_ID =  50 AND e2.JOB_ID = e.JOB_ID) AS 직무별5,
	(SELECT sum(SALARY) FROM EMPLOYEES e2 WHERE E2.DEPARTMENT_ID =  60 AND e2.JOB_ID = e.JOB_ID) AS 직무별6,
	(SELECT sum(SALARY) FROM EMPLOYEES e2 WHERE E2.DEPARTMENT_ID =  70 AND e2.JOB_ID = e.JOB_ID) AS 직무별7,
	(SELECT sum(SALARY) FROM EMPLOYEES e2 WHERE E2.DEPARTMENT_ID =  80 AND e2.JOB_ID = e.JOB_ID) AS 직무별8,
	(SELECT sum(SALARY) FROM EMPLOYEES e2 WHERE E2.DEPARTMENT_ID =  90 AND e2.JOB_ID = e.JOB_ID) AS 직무별9,
	(SELECT sum(SALARY) FROM EMPLOYEES e2 WHERE E2.DEPARTMENT_ID =  100 AND e2.JOB_ID = e.JOB_ID) AS 직무별10,
	(SELECT sum(SALARY) FROM EMPLOYEES e2 WHERE E2.DEPARTMENT_ID =  110 AND e2.JOB_ID = e.JOB_ID) AS 직무별11,
	(SELECT sum(SALARY) FROM EMPLOYEES e2 where e2.JOB_ID = e.JOB_ID) AS total	
FROM EMPLOYEES e 
GROUP BY JOB_ID 
ORDER BY JOB_ID ;

--서브쿼리 만 사용
-- joc_id가 sa_man 인 사원들의 최대 이연봉 보다 높게 받는 사원들의 last _name , job_id , salay 조회
SELECT
	e.LAST_NAME ,
	e.JOB_ID ,
	e.SALARY
FROM
	EMPLOYEES e
WHERE
	e.SALARY > ALL (
	SELECT
		max(e2.SALARY)
	FROM
		EMPLOYEES e2
	WHERE
		e2.JOB_ID = 'SA_MAN');
-- 커미션을 버는 사원들의 부서와 연봉이 동일한 사원들의 last_name , 부서번호, 연봉 조회
SELECT
	e.LAST_NAME ,
	e.DEPARTMENT_ID ,
	e.SALARY
FROM
	EMPLOYEES e
WHERE
	(e.SALARY,
	e.DEPARTMENT_ID )IN (
	SELECT
		e2.SALARY,
		e2.DEPARTMENT_ID
	FROM
		EMPLOYEES e2
	WHERE
		e.COMMISSION_PCT IS NOT NULL);
-- 회사 전체 평균 연봉보다 더 많이 버는 사원들 중  last_name에 u 가 있는 사원들이 근무하는 사원들의 사번, last _name , 연봉 조회
SELECT
	e.EMPLOYEE_ID ,
	e.LAST_NAME ,
	e.SALARY
FROM
	EMPLOYEES e
WHERE
	DEPARTMENT_ID IN(
	SELECT
		DISTINCT DEPARTMENT_ID
	FROM
		EMPLOYEES e2
	WHERE
		e2.SALARY > (
		SELECT
			avg(e2.SALARY)
		FROM
			EMPLOYEES e2)
		AND 
		LAST_NAME LIKE '%u%'); 
	
-- 각 부서별 평균 연봉보다 더 받는 동일 부서 근무사원들의 last_name , 부서번호, 연봉 및 해당 부서의 평균 연봉 조회 부서별 연봉을 기준 정렬
SELECT
	e1.LAST_NAME , e1.DEPARTMENT_ID  ,e1.SALARY , trunc(e2.dept_sal_avg, 0)
FROM EMPLOYEES e1, 
	(
	SELECT
		department_id ,
		avg(SALARY) AS dept_sal_avg
	FROM
		EMPLOYEES e
	GROUP BY
		DEpartment_id) E2
	WHERE e1.DEPARTMENT_ID  = e2. DEPARTMENT_ID AND e1.SALARY > e2.dept_sal_avg
ORDER BY e1.DEPARTMENT_ID ;

-- last_name 이 Davies 인 사람보다 후에 고용된 사원들의 last_name, hire_date 조회
SELECT
	e.LAST_NAME ,
	e.HIRE_DATE
FROM
	EMPLOYEES e
WHERE
	e.HIRE_DATE > (
	SELECT
		e2.HIRE_DATE
	FROM
		EMPLOYEES e2
	WHERE
		e2.last_name = 'Davies' );
-- last_name 이 KING 인 사원을 메니저로 두고 있는 모든 사원들의 last_name, ssalay 조회
SELECT
	e.LAST_NAME ,
	e.SALARY 
FROM
	EMPLOYEES e
WHERE
	e.MAnager_id IN (
	SELECT
		e2.employee_id
	FROM
		EMPLOYEES e2
	WHERE
		e2.last_name = 'King' );
-- last_name 이 Kochhar 인 사원과 동일한 연봉 및 커미션을 버는  사원들의 last_name, 부서번호,ssalay 조회 단 Korchhar 제외
SELECT
	e.LAST_NAME ,
	e.DEPARTMENT_ID ,
	e.SALARY 
FROM
	EMPLOYEES e
WHERE
	(e.SALARY , nvl(e.COMMISSION_PCT,0)) IN (
	SELECT
		e2.salary, nvl(e2.COMMISSION_PCT,0) 
	FROM
		EMPLOYEES e2
	WHERE
		e2.last_name = 'Kochhar' )
	AND e.LAST_NAME  != 'Kochhar';
--부서가 위치한 국가 id , r국가 이름 조회 / countries 테이블과 location, department 이용
SELECT
	DISTINCT l.country_id,
	c.COUNTRY_NAME
FROM
	LOCATIONS l
JOIN COUNTRIES c ON
	c.COUNTRY_ID = l.COUNTRY_ID
WHERE
	l.COUNTRY_ID 
	IN (
	SELECT
		l.COUNTRY_ID
	FROM
		DEPARTMENTS d
	WHERE
		d.location_id = l.location_id );
	
SELECT 
	COUNTRY_ID ,
	COUNTRY_NAME
FROM
	COUNTRIES c
WHERE
	country_id IN (
	SELECT
		l.COUNTRY_ID
	FROM
		LOCATIONS l ,
		( 
		SELECT
			location_ID
		FROM
			DEPARTMENTS d) d
	WHERE
		l.LOCATION_ID = d.LOCATION_ID );
--총 사원수 및 2013,2014,2015,2016 년도별 고용된 사원들의 총 수를 조회한다.
SELECT
	DISTINCT 
	(
	SELECT
		count(EMPLOYEE_ID) 
	FROM
		EMPLOYEES e )AS "총 사원수",(
	SELECT
		count(e2.EMPLOYEE_ID)
	FROM
		EMPLOYEES e2
	WHERE
		to_char(e2.hire_date, 'yyyy') BETWEEN '2013' AND '2016' )AS " 2013 ~2016 사원수"
FROM
	EMPLOYEES e;


SELECT DISTINCT 
	(
	SELECT
		count(EMPLOYEE_ID) 
	FROM
		EMPLOYEES e )AS "총 사원수",
	(
	SELECT
		count(EMPLOYEE_ID)
	FROM
		EMPLOYEES e
	WHERE
		to_char(hire_date, 'yy') = 13 ) AS "2013 사원수",
	(
	SELECT
		count(EMPLOYEE_ID)
	FROM
		EMPLOYEES e
	WHERE
		to_char(hire_date, 'yy') = 14 ) AS "2014 사원수",
	(
	SELECT
		count(EMPLOYEE_ID)
	FROM
		EMPLOYEES e
	WHERE
		to_char(hire_date, 'yy') = 15 ) AS "2015 사원수",
	(
	SELECT
		count(EMPLOYEE_ID)
	FROM
		EMPLOYEES e
	WHERE
		to_char(hire_date, 'yy') = 16 ) AS "2016 사원수"
FROM
	EMPLOYEES e ;
-- 위치 id 가 1700인 사원들의 연봉과 커미션을 추출한뒤 추출된 사원들의 연봉과 커미션이 동인한 사원정보 조회
--사원번호, 이름(first+last), 부서번호, 급여 출력
SELECT 
	EMPLOYEE_ID ,
	FIRST_NAME || ' ' || LAST_NAME AS name,
	DEPARTMENT_ID,
	SALARY 
FROM
	EMPLOYEES e
WHERE
	(SALARY,
	nvl(COMMISSION_PCT,0))
IN (
	SELECT
		SALARY ,
		nvl(COMMISSION_PCT,0)
	FROM
		EMPLOYEES e
	WHERE
		e.EMPLOYEE_ID IN (
		SELECT
			d.DEPARTMENT_ID
		FROM
			DEPARTMENTS d
		WHERE
			d.LOCATION_ID LIKE '1700'));
			
		
		
		
/*
 * 
 * 
 * 
 * 
 * 
 */
		
SELECT  * FROM EMPLOYEES e WHERE FIRST_NAME ='Jack';
/* 테이블 생성 - 구조, 데이터 복사*/
CREATE TABLE IDX_EMPLOYEES AS SELECT DISTINCT FIRST_NAME,LAST_NAME ,HIRE_DATE FROM EMPLOYEES ;

/* INDEX 생성*/
CREATE INDEX IDX_NAME ON IDX_EMPLOYEES(FIRST_NAME);

/*INDEX 사용해서 조회 => RANGE SCAN*/
SELECT  * FROM IDX_EMPLOYEES WHERE FIRST_NAME ='Jack';